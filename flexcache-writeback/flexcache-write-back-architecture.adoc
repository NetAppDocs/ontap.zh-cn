---
permalink: flexcache-writeback/flexcache-write-back-architecture.html 
sidebar: sidebar 
keywords: tr-4743, flexcache writeback, flexcache write-back, flexcache, write-back, write back, lock delegations, data delegations, dirty data, cache scrubbers, disconnected mode, grok it, sequence diagrams, technical report, netapp tr, ontap tr 
summary: 了解有关FlexCache回写操作的更详细信息。 
---
= FlexCache回写架构
:allow-uri-read: 


[role="lead"]
FlexCache在设计时充分考虑了一致性、包括两种写入操作模式：回写和绕写。传统的绕写操作模式和ONTAP 9.15.1中引入的新回写操作模式均可确保访问的数据始终保持100%一致、最新且一致。

以下概念详细介绍了FlexCache回写的操作方式。



== 委派

锁定委派和数据委派有助于FlexCache保持回写和绕写缓存数据的一致性、一致性和最新性。源服务器会编排这两个委派。



=== 锁定委派

锁定委派是指初始服务器按文件授予缓存的协议级锁定授权、用于根据需要向客户端发出协议锁定。其中包括 xref:flexcache-write-back-overview.html#flexcache-write-back-terminology[专用锁定委派(XD)] 和 xref:flexcache-write-back-overview.html#flexcache-write-back-terminology[共享锁定委派(SLD)]。

.XLD和回写
为了确保ONTAP不必协调冲突写入、将向客户端请求写入文件的缓存授予XLD。重要的是、任何文件在任何时候只能存在一个XLD、这意味着一个文件一次不会有多个写入程序。

当写入文件的请求进入启用了回写的缓存时、将执行以下步骤：

. 缓存会检查是否已为请求的文件创建了XLD。如果是这样、只要另一个客户端未向缓存中的文件写入数据、它就会为客户端授予写入锁定。如果缓存没有用于请求文件的XLD、则它将从原始位置请求一个。这是一个经过集群间网络的专有调用。
. 从缓存收到XLD-请求后、初始服务器将检查另一个缓存中的文件是否存在未完成的XLD-。如果是这样、它将调用该文件的XLD、从而触发从该缓存转储到原始缓存的任何 xref:flexcache-write-back-overview.html#flexcache-write-back-terminology[脏数据] 。
. 一旦将该缓存中的脏数据转储回来并提交到源站的稳定存储、源站将为请求缓存授予文件的XLD。
. 收到文件的XLD后、缓存会将锁定授予客户端、写入将开始。


序列图中介绍了涵盖其中某些步骤的高级序列图 <<write-back-sequence-diagram>> 。

从客户端的角度来看、所有锁定都将像写入标准FlexVol或FlexGroup一样工作、在请求写入锁定时可能会有一个小延迟。

在当前迭代中、如果启用了回写的缓存保存了文件的XLD、则ONTAP将阻止其他缓存对该文件的*任何*访问、包括 `READ` 操作。


NOTE: 每个原始成分卷的XLD限制为170。



=== 数据委派

数据委派是指初始卷为缓存提供的每个文件的保证、保证为该文件缓存的数据是最新的。只要缓存具有文件的数据委派、它就可以向客户端提供该文件的缓存数据、而无需联系源站。如果缓存没有文件的数据委派、它必须联系源站以接收客户端请求的数据。

在回写模式下、如果在另一个缓存或原始位置为文件创建了XLD、则文件的数据委派将被撤消。这样可以有效地将文件与所有其他缓存中的客户端和源服务器隔开、即使是读取也是如此。这是一种权衡、必须确保旧数据永远不会被访问。

启用了回写的缓存上的读取操作通常类似于绕写缓存上的读取操作。在启用了绕写和回写的缓存中、如果请求的文件在启用了回写的缓存(而不是发出读取的缓存)具有排他写锁定、则初始性能可能会 `READ` 受到影响。必须撤消XLD、并且必须先将脏数据提交到源站、然后才能处理其他缓存上的读取。



== 跟踪脏数据

从缓存回写源站的操作是异步进行的。这意味着脏数据不会立即写入源站。ONTAP使用脏数据记录系统来跟踪每个文件的脏数据。每个脏数据记录(脏数据记录、DDR)代表特定文件的大约20 MB脏数据。当正在写入文件时、ONTAP将在填充两个DDRR并写入第三个DDR后开始将脏数据转储回。这样、写入期间缓存中会保留大约40 MB的脏数据。对于有状态协议(NFSv4.x、SMB)、在关闭文件后、剩余的40 MB数据将转储回原始卷。对于无状态协议(NFSv3)、当在其他缓存上请求访问该文件时、或者在该文件闲置两分钟或更长时间(最长为五分钟)后、将转储40 MB的数据。有关计时器触发或空间触发的异常数据转储的详细信息，请参见 <<缓存擦除器>>。

除了CDR和擦除器之外、某些前端NAS操作还会触发文件的所有脏数据的转储：

* `SETATTR`
+
** `sETATTR`s只能在缓存中处理修改mttime、atme和/或ctime的操作，避免了WAN的影响。


* `CLOSE`
* `OPEN` 在另一个缓存中
* `READ` 在另一个缓存中
* `READDIR` 在另一个缓存中
* `READDIRPLUS` 在另一个缓存中
* `WRITE` 在另一个缓存中




== 已断开连接模式

如果文件的XLD保存在绕写缓存中、并且该缓存与原始缓存断开连接、则仍允许在其他缓存和原始缓存中读取该文件。如果XLD由启用了回写的缓存保留、则此行为会有所不同。在这种情况下、如果缓存断开连接、则对文件的读取将在任何地方挂起。这有助于确保保持100%的一致性、一致性和一致性。允许在绕写模式下进行读取、因为保证源站拥有已向客户端写入确认的所有可用数据。在断开连接期间的回写模式下、初始卷无法保证已启用回写的缓存中写入并确认的所有数据都在断开连接之前写入到初始卷。

如果文件的具有XLD的缓存长时间断开连接、系统管理员可以手动在原始位置撤消XLD。这样、该文件的IO便可在运行正常的缓存和原始卷上恢复。


WARNING: 手动恢复XLD将导致断开连接的缓存中文件的任何脏数据丢失。只有在缓存和源站之间发生灾难性中断时、才应手动删除XLD。



== 缓存擦除器

ONTAP中存在一些擦除了程序、它们会根据特定事件运行、例如计时器即将过期或违反空间阈值。擦除程序会对正在擦除的文件进行独占锁定、从而有效冻结该文件的IO、直到擦除完成为止。

擦尘器包括：

* 缓存上的*基于时间的清理程序：*此清理程序每五分钟启动一次，并擦除任何未经修改的文件两分钟。如果此文件的任何脏数据仍在缓存中、则此文件的IO将被静置并触发回写。回写完成后、IO将恢复。
* 与缓存中基于mtime的清理程序非常相似，该程序也每五分钟运行一次。但是、它会将未修改的任何文件进行15分钟的反转、从而重新调用索引节点的委派。此擦除程序不会启动任何回写。
* *RW基于限制的清理程序在源站：* ONTAP可监控每个源站成分卷分发的RW锁定委派的数量。如果此数字超过170、则ONTAP将开始擦除最近最少使用的写入锁定委派(Least Recently Used、LRU)。
* *缓存上基于空间的擦除程序：*如果FlexCache卷已满90%、则会擦除缓存、并按LRU逐出。
* *基于空间的擦除程序：*如果FlexCache初始卷已满90%、则会擦除缓存、并按LRU逐出。




== 序列图

这些顺序图显示了绕写模式与回写模式之间的写入确定差异。



=== 绕写

image::flexcache-write-around-sequence-diagram.png[FlexCache绕写序列图]



=== 回写

image::flexcache-write-back-sequence-diagram.png[FlexCache回写顺序图]
